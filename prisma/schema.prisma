generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "sqlite"
}

model Conversation {
  id         String    @id @default(cuid())
  title      String    @default("New Chat")
  model      String    @default("auto")
  ragEnabled    Boolean   @default(true)
  memoryEnabled Boolean   @default(true)
  systemPrompt  String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  messages      Message[]
  memoryItems   MemoryItem[]
}

model Message {
  id             String       @id @default(cuid())
  role           String       // "user" or "assistant"
  content        String
  model          String?      // which model handled this message (null for user messages)
  groundingConfidence String? // "high" | "medium" | "low"
  groundingReason     String?
  groundingAvgSimilarity Float?
  groundingUsedChunkCount Int?
  usedMemoryIds     String? // JSON array of memory item IDs injected for this assistant response
  createdAt      DateTime     @default(now())
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  conversationId String
  citations      MessageCitation[]
  sourceMemories MemoryItem[] @relation("MemorySourceMessage")

  @@index([conversationId])
}

model Document {
  id         String   @id @default(cuid())
  filename   String
  filepath   String?
  sourceUrl  String?
  sourceType String   // "markdown" | "text" | "pdf" | "code" | "url"
  mimeType   String?
  fileSize   Int?
  hash       String   // SHA-256 for dedup/change detection
  status     String   @default("pending") // "pending" | "processing" | "indexed" | "error"
  error      String?
  chunkCount Int      @default(0)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  chunks     Chunk[]
  citations  MessageCitation[]

  @@index([hash])
  @@index([status])
}

model Chunk {
  id         String   @id @default(cuid())
  documentId String
  content    String
  tokenCount Int
  chunkIndex Int
  metadata   String?  // JSON: { language, startLine, endLine, heading, etc. }
  createdAt  DateTime @default(now())
  document   Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@index([documentId])
}

model MessageCitation {
  id         String   @id @default(cuid())
  messageId  String
  documentId String
  filename   String
  chunkIndex Int
  score      Float
  metadata   String?
  createdAt  DateTime @default(now())
  message    Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)
  document   Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@index([messageId])
  @@index([documentId])
}

model RagConfig {
  id                  String  @id @default("default")
  chunkSize           Int     @default(500)
  chunkOverlap        Int     @default(50)
  topK                Int     @default(5)
  similarityThreshold Float   @default(0.7)
  embeddingModel      String  @default("nomic-embed-text")
  ragEnabled          Boolean @default(true)
  watchedFolders      String  @default("[]")
  supportedTypes      String  @default("[\"md\",\"txt\",\"pdf\",\"ts\",\"js\",\"py\",\"go\",\"rs\",\"java\",\"cpp\",\"c\",\"html\",\"css\",\"json\",\"yaml\",\"toml\"]")
}

model AppConfig {
  id             String @id @default("singleton")
  defaultModel   String @default("")
  codeModel      String @default("")
  embeddingModel String @default("")
  memoryTokenBudget Int @default(2000)
}

model MemoryItem {
  id                String        @id @default(cuid())
  type              String        // "preference" | "fact" | "decision"
  content           String
  scope             String        // "global" | "conversation"
  conversationId    String?
  sourceMessageId   String?
  status            String        @default("active") // "active" | "archived"
  supersedesMemoryId String?
  tags              String        @default("[]")
  lastUsedAt        DateTime?
  useCount          Int           @default(0)
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  conversation      Conversation? @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sourceMessage     Message?      @relation("MemorySourceMessage", fields: [sourceMessageId], references: [id], onDelete: SetNull)
  supersedesMemory  MemoryItem?   @relation("MemorySupersede", fields: [supersedesMemoryId], references: [id], onDelete: SetNull)
  supersededBy      MemoryItem[]  @relation("MemorySupersede")

  @@index([status, type, scope, updatedAt])
  @@index([conversationId, status])
}
